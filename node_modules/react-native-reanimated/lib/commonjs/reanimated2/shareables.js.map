{"version":3,"names":["USE_STUB_IMPLEMENTATION","shouldBeUseWeb","_shareableCache","WeakMap","_shareableFlag","Symbol","MAGIC_KEY","isHostObject","value","registerShareableMapping","shareable","shareableRef","set","makeShareableCloneRecursive","shouldPersistRemote","type","cached","get","undefined","toAdapt","Array","isArray","map","element","__workletHash","__DEV__","registerWorkletStackDetails","__stackDetails","__initData","key","Object","entries","freeze","adopted","NativeReanimatedModule","makeShareableClone","makeShareableCloneOnUIRecursive","cloneRecursive","_makeShareableClone","makeShareable","handle","__init"],"sources":["shareables.ts"],"sourcesContent":["import NativeReanimatedModule from './NativeReanimated';\nimport { ShareableRef } from './commonTypes';\nimport { shouldBeUseWeb } from './PlatformChecker';\nimport { registerWorkletStackDetails } from './errors';\n\n// for web/chrome debugger/jest environments this file provides a stub implementation\n// where no shareable references are used. Instead, the objects themselves are used\n// instead of shareable references, because of the fact that we don't have to deal with\n// runnning the code on separate VMs.\nconst USE_STUB_IMPLEMENTATION = shouldBeUseWeb();\n\nconst _shareableCache = new WeakMap<\n  Record<string, unknown>,\n  ShareableRef<any> | symbol\n>();\n// the below symbol is used to represent a mapping from the value to itself\n// this is used to allow for a converted shareable to be passed to makeShareableClone\nconst _shareableFlag = Symbol('shareable flag');\n\nconst MAGIC_KEY = 'REANIMATED_MAGIC_KEY';\n\nfunction isHostObject(value: any): boolean {\n  // We could use JSI to determine whether an object is a host object, however\n  // the below workaround works well and is way faster than an additional JSI call.\n  // We use the fact that host objects have broken implementation of `hasOwnProperty`\n  // and hence return true for all `in` checks regardless of the key we ask for.\n  return MAGIC_KEY in value;\n}\n\nexport function registerShareableMapping(\n  shareable: any,\n  shareableRef?: ShareableRef<any>\n): void {\n  if (USE_STUB_IMPLEMENTATION) {\n    return;\n  }\n  _shareableCache.set(shareable, shareableRef || _shareableFlag);\n}\n\nexport function makeShareableCloneRecursive<T>(\n  value: any,\n  shouldPersistRemote = false\n): ShareableRef<T> {\n  if (USE_STUB_IMPLEMENTATION) {\n    return value;\n  }\n  // This one actually may be worth to be moved to c++, we also need similar logic to run on the UI thread\n  const type = typeof value;\n  if ((type === 'object' || type === 'function') && value !== null) {\n    const cached = _shareableCache.get(value);\n    if (cached === _shareableFlag) {\n      return value;\n    } else if (cached !== undefined) {\n      return cached as ShareableRef<T>;\n    } else {\n      let toAdapt: any;\n      if (Array.isArray(value)) {\n        toAdapt = value.map((element) => makeShareableCloneRecursive(element));\n      } else if (type === 'function' && value.__workletHash === undefined) {\n        // this is a remote function\n        toAdapt = value;\n      } else if (isHostObject(value)) {\n        // for host objects we pass the reference to the object as shareable and\n        // then recreate new host object wrapping the same instance on the UI thread.\n        // there is no point of iterating over keys as we do for regular objects.\n        toAdapt = value;\n      } else {\n        toAdapt = {};\n        if (value.__workletHash !== undefined) {\n          // we are converting a worklet\n          if (__DEV__) {\n            registerWorkletStackDetails(\n              value.__workletHash,\n              value.__stackDetails\n            );\n            delete value.__stackDetails;\n          }\n          // to save on transferring static __initData field of worklet structure\n          // we request shareable value to persist its UI counterpart. This means\n          // that the __initData field that contains long strings represeting the\n          // worklet code, source map, and location, will always be\n          // serialized/deserialized once.\n          toAdapt.__initData = makeShareableCloneRecursive(\n            value.__initData,\n            true\n          );\n          delete value.__initData;\n        }\n\n        for (const [key, element] of Object.entries(value)) {\n          toAdapt[key] = makeShareableCloneRecursive(element);\n        }\n      }\n      if (__DEV__) {\n        // we freeze objects that are transformed to shareable. This should help\n        // detect issues when someone modifies data after it's been converted to\n        // shareable. Meaning that they may be doing a faulty assumption in their\n        // code expecting that the updates are going to automatically populate to\n        // the object sent to the UI thread. If the user really wants some objects\n        // to be mutable they should use shared values instead.\n        Object.freeze(value);\n      }\n      const adopted = NativeReanimatedModule.makeShareableClone(\n        toAdapt,\n        shouldPersistRemote\n      );\n      _shareableCache.set(value, adopted);\n      _shareableCache.set(adopted, _shareableFlag);\n      return adopted;\n    }\n  }\n  return NativeReanimatedModule.makeShareableClone(value, shouldPersistRemote);\n}\n\nexport function makeShareableCloneOnUIRecursive<T>(value: T): ShareableRef<T> {\n  'worklet';\n  if (USE_STUB_IMPLEMENTATION) {\n    // @ts-ignore web is an interesting place where we don't run a secondary VM on the UI thread\n    // see more details in the comment where USE_STUB_IMPLEMENTATION is defined.\n    return value;\n  }\n  function cloneRecursive<T>(value: T): ShareableRef<T> {\n    const type = typeof value;\n    if ((type === 'object' || type === 'function') && value !== null) {\n      let toAdapt: any;\n      if (Array.isArray(value)) {\n        toAdapt = value.map((element) => cloneRecursive(element));\n      } else {\n        toAdapt = {};\n        for (const [key, element] of Object.entries(value)) {\n          toAdapt[key] = cloneRecursive(element);\n        }\n      }\n      if (__DEV__) {\n        // See the reasoning behind freezing in the other comment above.\n        Object.freeze(value);\n      }\n      return _makeShareableClone(toAdapt);\n    }\n    return _makeShareableClone(value);\n  }\n  return cloneRecursive(value);\n}\n\nexport function makeShareable<T>(value: T): T {\n  if (USE_STUB_IMPLEMENTATION) {\n    return value;\n  }\n  const handle = makeShareableCloneRecursive({\n    __init: () => {\n      'worklet';\n      return value;\n    },\n  });\n  registerShareableMapping(value, handle);\n  return value;\n}\n"],"mappings":"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"}